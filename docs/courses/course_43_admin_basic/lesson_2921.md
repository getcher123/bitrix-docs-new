# Работа с базами данных

**Навигация**
- [← Оглавление курса](index.md)
- [← Предыдущий: 2819 — Права доступа](lesson_2819.md)
- [Следующий: 3489 — Отложенные функции →](lesson_3489.md)

Официальная страница урока: https://dev.1c-bitrix.ru/learning/course/index.php?COURSE_ID=43&LESSON_ID=2921

Одним из первых впечатлений, возникающих у начинающего осваивать Bitrix Framework программиста, бывает непонимание запросов к базе данных. Код Bitrix Framework порождает очень большие и не сразу понятные запросы. Несколько экранов не очень понятного SQL традиционно пугают людей, которые редко пишут запросы сложнее `select * from ... where id=...` и увереных, что объединение таблиц по условиям делается через **where** так же производительно, как и через **on**.

Но всё не так просто. Тема работы с БД включает в себя вопросы:

- узкотехнологические, вроде производительности конкретных выборок;
- вопросы удобного применения технологий работы с БД в больших развиваемых проектах на растущей CMS;
- вопросы стоимости владения и поддержки.

#### Почему в Bitrix Framework запрос получается неудобочитаемым?

В системе есть инфоблоки, где быстро и комфортно создается структура данных. Есть стандартные компоненты, реализующие наиболее распространенные вещи. Есть API, позволяющее отправлять достаточно произвольные запросы. Вы работаете со всем этим, в итоге ваша достаточно высокоуровневая логика выборки превращается в запрос. Генератор запроса, несмотря на свою сложность, выполняет довольно однообразную работу по переводу логики, изложенной на высоком уровне, в обращения к конкретным полям конкретных таблиц по условиям.

В мощных СУБД есть умные и очень эффективные оптимизаторы запросов, а совсем плохие запросы такие СУБД даже не дают исполнять. Подавляющее большинство установок продуктов на Bitrix Framework работают на **MySQL**, чей оптимизатор достаточно слаб. В итоге мы имеем большие запросы, ограниченные средства их изменения с сохранением логики, и механизмы кеширования поверх всего этого.

#### Минус такого положения дел

Сложные запросы очень велики и вы почти не можете влиять на их структуру. Даже если есть желание заняться их профилировкой и отладкой, вы фактически ограничены теми не слишком богатыми средствами изменения запроса, которые предлагает Bitrix Framework. Вы не можете:

- изменять порядок объединений;
- задавать специфические условия на выборки;
- создавать локальные кеширующие временные таблицы.

#### Плюсы такого положения дел

Плюсы оказываются важнее, чем минусы:

- **Запросы не надо писать руками**. Создание проекта на Bitrix Framework обычно предусматривает визуальную настройку готовых компонентов, создании структуры сайта и интеграцию дизайна. Не в каждом проекте приходится кастомизировать компоненты, но даже эта работа не заставляет писать запросы.
- **Безопасность**. Обертки над запросами решают задачу защиты от атак или глупостей разработчика.

#### Квалификация разработчика

Как и в любом другом деле, всё решает профессионализм работы с Bitrix Framework. И мастерство работы с БД не играет существенной роли. Объективно в большинстве проектов нагрузка на sql (время исполнения) несущественна по сравнению с нагрузкой на процессор и затратами на интерпретацию скриптов. **Тормозит не MySQL, а PHP**.

В связи с этим огромную роль играет правильность проектирования структуры данных, выбор связей и их реализация средствами системы инфоблоков или таблиц. **Устранить "тормоза" на проекте гораздо правильнее и эффективнее грамотным проектированием, чем оптимизацией запроса**, который Bitrix Framework генерирует по вашим указаниям.

Использование кеширования позволяет сэкономить на времени исполнения запросов. Грамотное распределение логики по компонентам позволяет вообще их не вызывать. Есть правило: **главная страница сайта (обычно не самая простая) не должна отправлять запросы к БД при включенном кеше**.

Разработчик должен учитывать специфику проекта и правильно выбирать тип таблиц: **InnoDB** или **MyISAM** .

Разработчик должен уметь оценивать уровень задач. Для действительно серьезных проектов есть кластеризация **My SQL**.

#### Что есть в Bitrix Framework для облегчения жизни простого программиста?

Перед началом работ по оптимизации проектов воспользуйтесь [Монитором производительности](http://dev.1c-bitrix.ru/learning/course/index.php?COURSE_ID=32&CHAPTER_ID=1146) для поиска узких мест на сайте.

В составе административной части системы есть инструменты [проверки БД](http://dev.1c-bitrix.ru/learning/course/index.php?COURSE_ID=35&LESSON_ID=2032) и [её оптимизации](http://dev.1c-bitrix.ru/learning/course/index.php?COURSE_ID=32&LESSON_ID=5132). Эти действия автоматизированы и вмешательство разработчика в них исключено.

Используйте [инфоблоки 2.0](lesson_2723.md). Это включаемый галочкой в административном разделе режим работы инфоблока, когда его поля переносятся в отдельную таблицу. Но у них есть свои особенности, которые надо знать и учитывать.

Используйте настраиваемую из административной части [кластеризацию БД](https://dev.1c-bitrix.ru/learning/course/index.php?COURSE_ID=35&CHAPTER_ID=04750) на стандартных механизмах MySQL.

Используйте специфические для вашего проекта [индексы](https://dev.1c-bitrix.ru/learning/course/index.php?COURSE_ID=32&LESSON_ID=3798). Большой запрос не всегда синоним долгого исполнения. Возьмите тяжелый запрос из системы и сделайте **explain** в консоли. Вы удивитесь как хорошо он покрыт индексами и как мало там будет циклических переборов записей.

#### Работа с БД

Перед тем как начать работать с БД усвойте, что:

**Внимание!** Прямое обращение к базе данных в рамках Bitrix Framework не приветствуется. Более того, если речь идет о системных таблицах самого Bitrix Framework, это не просто не приветствуется, это не поддерживается.  Необходимо с ними работать через API системы, так как физическая структура БД может измениться, а работа даже самого древнего API гарантирована.

В силу этого предупреждения названия таблиц не афишируются. Если, все же, вы возьмёте на себя ответственность прямой работы с базой данных, то учтите, что все таблицы от Bitrix Framework начинаются с **b_**. Соответственно ваши префиксы должны быть другими: необходимо чтобы имена ваших таблиц не пересеклись с битриксовыми. Вполне возможна ситуация, когда в новых обновлениях появится таблица с таким же именем, как и созданная вами (если вы используете префикс **b_**). В лучшем случае обновление не установится.

Для работы с собственными таблицами используйте методы глобальной переменной [$DB](http://dev.1c-bitrix.ru/api_help/main/general/magic_vars.php#db) (класс [CDatabase](http://dev.1c-bitrix.ru/api_help/main/reference/cdatabase/index.php)).

Детально об оптимизации БД читайте в главе [Оптимизация базы данных](https://dev.1c-bitrix.ru/learning/course/index.php?COURSE_ID=32&CHAPTER_ID=1145) **Курса для хостеров**.

|  |
| --- |

Список ссылок по теме:

- [План действий при проблемах](lesson_2334.md)
- [Кардинально ускоряем Bitrix+MSSQL](https://dev.1c-bitrix.ru/community/webdev/user/5499/blog/1517/) (блог)
- [Проблема с deadlock на MSSQL](https://dev.1c-bitrix.ru/community/blogs/Kobzar/the-problem-with-deadlock-on-mssql.php) (блог)
- [Пример оптимизации работы MySQL](https://dev.1c-bitrix.ru/community/webdev/user/23706/blog/1472/)
- [11 «рецептов приготовления» MySQL в Битрикс24](https://habrahabr.ru/company/bitrix/blog/147098)
