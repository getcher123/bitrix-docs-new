# Класс объекта

**Навигация**
- [← Оглавление курса](index.md)
- [← Предыдущий: 2244 — Операции с сущностями](lesson_2244.md)
- [Следующий: 11691 — Именованные методы →](lesson_11691.md)

Официальная страница урока: https://dev.1c-bitrix.ru/learning/course/index.php?COURSE_ID=43&LESSON_ID=11689

Все объекты сущностей являются наследниками класса *Bitrix\Main\ORM\Objectify\EntityObject*, при этом у каждой сущности – свой собственный класс для объектов. По умолчанию, такой класс создается автоматически, на лету. Если вы уже сгенерировали [аннотации классов ORM](lesson_11733.md), то IDE раскроет этот момент:

![](../../../images/courses/43/dev.1c-bitrix.ru/images/dev_full/d_7/ORM/auto_book_eo.jpg)

Как видно, класс объекта *EO_Book* находится в том же пространстве имен, что и класс *Table*, так же назван, но вместо суффикса *Table* имеет префикс *EO_* (аббревиатура *EntityObject*). Такой префикс добавлен из соображений обратной совместимости: в существующих проектах уже может быть класс *Book* или конструкция вида

```
use Some\Another\Book;
```

 что приведет к конфликту повторного использования слова *Book*. Мы посчитали префикс *EO_* достаточно уникальным, тем более в обычном случае использование знака **_** противоречит [стандартам именования кода](lesson_3524.md), и конфликтов с вручную описанными классами быть не должно.

При этом мы заложили возможность указать свое собственное, красивое имя класса, и даже разместить его в другом пространстве имен при необходимости:

```
//Файл bitrix/modules/main/lib/test/typography/book.php

namespace Bitrix\Main\Test\Typography;

class Book extends EO_Book
{
}
```

Ключевой момент - наследование от базового виртуального класса объекта *EO_Book*.

Сущность нужно уведомить о новом классе следующим образом:

```
//Файл bitrix/modules/main/lib/test/typography/booktable.php

namespace Bitrix\Main\Test\Typography;

class BookTable extends Bitrix\Main\ORM\Data\DataManager
{
	public static function getObjectClass()
	{
		return Book::class;
	}
	//...
}
```

Теперь метод *fetchObject* будет возвращать объекты класса *Bitrix\Main\Test\Typography\Book*. А после [перегенерации аннотаций](lesson_11733.md) новый класс начнет показывать IDE:

![](../../../images/courses/43/dev.1c-bitrix.ru/images/dev_full/d_7/ORM/auto_book.jpg)

Определять собственные классы объектов стоит лишь тогда, когда вам требуется явно использовать имя класса или расширить класс своим функционалом. Не рекомендуется использовать имена стандартных классов в своем коде, например *instanceof EO_Book*, *new EO_Book* или *EO_Book::class*. В таких случаях рекомендуется описать свой класс с «красивым» именем, соответствующий стандартам именования, либо использовать обезличенные методы *BookTable::getObjectClass()*, *BookTable::createObject()*, *BookTable::wakeUpObject()* и т.п.

В своем классе можно не только добавлять свой функционал, но и переопределять стандартные именованные методы. Не следует лишь описывать в классе свойства с именами *primary*, *entity* и *dataClass*, поскольку эти имена уже используются базовым классом.
